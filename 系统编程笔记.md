## 文件与I/O函数

### open函数

- 头文件：`<sys/types.h>, <sys/stat.h>, <fcntl.h>`
- 返回值：成功返回非零整数，失败返回-1。
- 执行类型：`O_RDONLY, O_WRONLY, O_RDWR, O_CREAT`

```c
int fd;
fd = open("hello.txt", O_RDWR)    //打卡文件
fd = open("hello.txt", O_RDWR|O_CREAT, 0777)  //创建文件 但实际hello.txt文件权限并不是777结果回事775，余umask掩码有关
fd = open("hello.txt", O_RDWR|O_TRUNC)     //截断操作，此操作会将hello.txt文件中的内容清空
```

### close函数

- 头文件：`<unistd.h>`

- 函数原型：

  ```c
  int close(int fd);
  ```

- 参数: fd 文件描述符

- 返回值：成功返回0， 失败返回-1。

### read函数

- 头文件：`<unistd.h>`

- 函数原型

  ```c
  int read(int fd, void *buf, int size); 
  ```

- 返回值：

  失败返回 -1；

  文件读完返回0；

  读取的字节数返回的数大于0；

  

### write函数

- 头文件`<unistd.h>`

- 函数原型：

  ```c
  int write(int fd, void *buf, int size);
  ```

- 返回值：写入的字节数。

### lseek函数

头文件`<sys/types.h>, <unistd.h>`

功能：获取文件长度，移动文件指针。

### 复制文件示例代码

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    int fd;
    fd = open("hello.txt", O_RDONLY);  //打开要复制的文件
    if(fd == -1){
        perror("open error");
        exit(1);
    }
    
    int fd1;
    fd1 = open("newfile.txt", 	O_WRONLY | O_CREAR, 0777);   //新建文件
    if(fd1 == -1){
        perror("open error");
        exit(1);
    }
    
    int count;
    char buf[1024];
    count = read(fd, buf, sizeof(buf));     //读取fd文件描述符里面的内容
    if(count == -1){
        perror("read error");
        exit(1);
    }
    
    //count是read函数的返回值，如果count大于零说明fd描述符对应文件中的内容还没有全部被读完。读完的话count会置位为0；
    while(count){
        int alreadyRead;
        alreadyRead = write(fd1, buf, count);
        printf("written %d bytes\n", alreadyRead);
        count = read(fd, buf, sizeof(buf));
    }
    
    //关闭文件
    close(fd);
    close(fd1);
    return 0;
}
```

### 文件共享

![](/home/zhang/Pictures/Screenshot from 2021-04-14 09-34-30.png)

![](/home/zhang/Pictures/Screenshot from 2021-04-14 09-34-46.png)

![](/home/zhang/Pictures/Screenshot from 2021-04-14 10-06-25.png)

### 复制文件描述符

![](/home/zhang/Pictures/Screenshot from 2021-04-14 10-07-37.png)

- 文件描述符复制有三种方法

  dup : 搜索空闲的文件描述符来完成复制，跟要复制的文件描述符指向同一个文件

  dup2：强制使用一个新的文件描述符来进行复制（不管原来文件描述符是否空闲）

  fcntl

- `fcntl(fd, F_DUPFD, fd_start);`



## 进程

### 程序

​	完成特定任务的一系列指令集合。

### 进程

中断技术产生之后，才有了进程这个概念。

- 从用户角度来说，进程是程序的一次动态执行过程。
- 从操作系统的核心来看，进程是操作系统分配的内存，cpu时间片等资源的基础单位。
- 进程是资源分配的最小单位。
- 每一个进程都有自己**独立的地址空间和执行状态**。

### PCB

操作系统感知进程存在的一个重要数据结构。

### 程序与进程的差别

- 进程是动态的，程序是静态的。
- 进程生命周期相对短暂，程序是永久的。
- 进程数据结构（PCB）

- 一个进程只能对应一个程序，一个程序可以对应多个进程。

### 进程状态转换

- 就绪态
- 运行态
- 等待态

![](/home/zhang/Pictures/Screenshot from 2021-04-13 10-08-27.png)

### 进程控制块

Windows下的任务管理器，显示的进程信息，就是存储在PCB中的。

#### 进程描述信息

- 进程标识符用于唯一的标识一个进程。`pid,  ppid`

#### 进程控制信息

- 进程当前状态：    `就绪态， 运行态， 等待态`
- 进程优先级：    调度进程的重要依据
- 程序开始地址
- 各种计时信息
- 通信信息

#### 资源信息

- 占用内存大小及管理用数据结构指针
- 交换区相关信息： 支持虚拟内存的操作系统会保存此项信息。
- I/O设备号， 缓冲， 设备相关的数据结构
- 文件系统的相关指针： 进程打开了哪些文件

#### 现场保护信息

因进程是断断续续执行的， 下一次在执行的时候，应该知道自己应该从哪个地方开始。

- 寄存器
- PC
- 程序状态字PSW
- 栈指针

### 进程标识

- 每个进程都会分配到一个独一无二的数字编号，我们称之为“进程标识”（process identifier），简称PID
- 是一个整数
- 当一个进程被启动，它会顺序挑选下一个未使用的编号数字作为自己的PID
- 数字1一般为特殊进程init保留的 **还有个0号进程是内核进程， init进程是用户进程**。

### 进程创建

- 不同的操作系统所提供的进程创建原语的名称和格式不尽相同，但执行创建进程原语后，操作系统所做的工作却大	致相同，都包括以下几点：
- 给新创建的进程分配一个内部标识（pid），在内核中建立进程结构，即创建PCB。
- 复制父进程的环境
- 为进程分配资源，包括进程映像所需要的所有元素（程序， 数据， 用户栈等）
- 复制父进程地址空间的内容到改进程地址空间中
- 将PCB中的该进程的状态设为就绪，插入到就绪队列。

### 进程撤销

进程终止时操作系统做一下工作：

- **关闭软中断**：因为进程即将终止而不在处理任何软中断信号
- **回收资源**： 释放进程分配的所有资源，如关闭所有已经打开文件，释放进程相应的数据结构等
- **写记账信息**：进程在运行过程中产生的记账数据（如进程运行时的各种统计信息）
- **置该进程为僵尸状态**：
- **转进程调度**：因为此时cpu已经释放，需要由进程调度进行cpu再分配。

### 终止进程的五种方法

- 正常退出

  从main函数返回    `return语句`

  调用exit 这是C的函数库

  调用_exit 这是系统调用

- 异常退出

  调用abort 它会产生一个SIGABRT信号

  由信号终止  Ctrl+C 使用了SIGINT信号

### 复制一个进程映像fork

- 使用fork函数得到的子进程从父进程的继承了整个进程的地址空间， 包括：进程上下问，进程堆栈，内存信息，打开的文件描述符，信号控制设置，进程优先级，进程组号，当前工作目录，根目录，资源限制，控制终端等。

- 子进程与父进程的区别

  父进程设置的锁，子进程不继承

  各自的进程ID和父进程ID不同

  子进程的未决告警被清除

  子进程的未决信号集设置为空集

### fork系统调用

==一次调用，两次返回==。 为什么是两次返回：它们是在各自的进程地址空间中返回的。

- 包含头文件`<sys/types.h>`和`<unistd.h>`

- 函数功能：创建一个子进程

- 函数原型：

  `pid_t fork()`

- 参数： 无参数

- 返回值：

  如果成功创建一个子进程，对于父进程来说返回子进程ID

  如果成功创建一个子进程，对于子进程来说返回值为0

  如果为-1表示创建失败

### fork系统调用注意事项

- fork系统调用之后，父子进程将交替执行（顺序不确定，有调度算法决定）

- 如果父进程先退出，子进程还没有退出，那么子进程的父进程将变为**init进程**。（PS：任何一个进程都必须有父进程），此进程也就变成了**孤儿进程**。

- 如果子进程先退出，父进程还没有退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候进程就成为**僵尸进程**。

  **避免僵尸进程的方法**引入头文件`<signal.h>`  加入语句 `signal(SIGCHLD, SIG_IGN)`.

### 系统是如何实现fork

**写时复制**：资源需要修改时，才进行复制。否则进行资源共享即可。

### fork之后父子进程如何共享文件

![](/home/zhang/Pictures/Screenshot from 2021-04-13 12-58-46.png)

父子进程指向相同的文件表， refcnt 引用计数器。

### fork与vfork

==fork不共享地址空间，vfork共享地址空间。==

- 在fork还没实现copy on write 之前。 Unix设计者很关心fork之后立刻执行exec所造成的地址空间浪费，所以引入了vfork系统调用。
- vfork有个限制，子进程必须立刻执行_exit或者exec函数。
- 即使fork实现了copy on write， 效率也没有vfork高， 但是我们不推荐使用vfork，因为几乎每个vfork的实现，都或多或少存在一定问题。

### exit与_exit

![](/home/zhang/Pictures/Screenshot from 2021-04-13 15-15-04.png)

- _exit ： 系统调用
- exit ：  C库函数    清除I/O缓冲区    调用终止处理程序

### exec替换进程映像

- 在进程的创建上Unix采用了一个独特的方法，它将进程创建与加载一个新进程映像分离。这样的好处是有更多的余地对两种操作进行管理。

**解释：**

```shell
$ ps
```

​	shell本身就是一个进程，如果再执行 ps命令的话，需要fork出一个新进程。

​	但fork创建的进程，新进程与原进程一样。因此**exec函数**就登场了， 为了将新进程用ps程序替换。

- 当我们创建了一个进程后，通常将子进程替换成新的进程映像，这可以用exec系列的函数来进行。当然，exec系列的函数也可以将当前进程替换掉。替换

### exec关联函数组

- 包含头文件`<unistd.h> `

- 功能用exec函数可以把当前进程替换为一个新进程。exec名下是由多个关联函数组成的一个完整系列。

- 原型

  ```c
  /* 可变参数 */
  int execl(const char *path, const char *arg, ...);
  int execlp(const char *path, const char *arg, ...);
  int execle(const char *path, const char *arg, char *const envp[]);
  
  /* 不可变参数 */
  int execv(const char *path, char *const argv[]);
  int execvp(const char *path, char *const argv[]);
  ```

- 参数

  path：表示你要启动程序的名称包括路径名

  arg：表示启动程序所带的参数

- 返回值 

  成功返回0， 失败返回-1

上述函数的execlp和execvp差别只是将execlp第一个参数后面的参数用args[ ]替代了。

**execlp例子**

```c
int main(){
    char *const args[] = {"ls", "-l", NULL};
    printf("Entering main ....\n");
    execlp("ls", "ls", "-l", NULL);  //将当前进程替换掉 
    printf("Exiting main ...\n");
    return 0;
}
```

**execvp例子**

```c
int main(){
    char *const args[] = {"ls", "-l", NULL};
    printf("Entering main ....\n");
   	execvp("ls", args);
    printf("Exiting main ...\n");
    return 0;
}
```

execl余execlp差别：带p的会利用环境变量来查找文件，不带p的必须指定路径execl才会起作用。

故execv与execvp和上面的情况也是一样的。

**execl例子**

```c
int main(){
    printf("Entering main ....\n");
    int ret = execl("ls", "ls", "-l", NULL);  //将当前进程替换掉 
    if (ret == -1)
        perror("execl error");
    printf("Exiting main ...\n");
    return 0;
}
```

输出信息

```shell
Entering main ....
execl error: No such file or directory
Exiting main ...
```

### SIGCHLD

- 当子进程退出的时候，内核会向父进程发送SIGCHLD信号， 子进程的退出是异步事件，（子进程可以在父进程运行的任何时刻停止）。
- 子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，他只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态。
- 父进程查询子进程的退出状态可以用`wait/waitpid函数`

### wait函数

- 头文件`<sys/types.h>和<sys/wait.h>`

- 函数功能：当我们用fork启动一个进程时， 子进程就有了自己的生命，并将独立的运行。有时，我们需要知道某个子进程是否已经结束了，我们可以通过`wait`安排父进程在子进程结束之后。

- 函数原型

  ```c
  pid_t wait(int *status)
  ```

- 函数参数

  `status:`该参数可以获得你等待子进程的信息

- 返回值

  成功等待子进程函数返回等待子进程的ID

1. wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。
2. 返回的是子进程的PID，它通常是结束的子进程。
3. 状态信息允许父进程判定子进程的退出状态，即从子进程的main函数返回的值或进程中exit语句的退出码。
4. 如果statu不是一个空指针，状态信息将被写入它指向的位置。

### waitpid函数

- 函数功能：用来等待某个特定进程的结束

- 函数原型

  ```c
  pid_t waitpid(pid_t pid, int *status, int options)
  ```

- 参数

  status:如果不是空，会把状态信息写到它指向的位置。

  options：允许改变waitpid的行为，最有用的一个选项是**WNOHANG**,它的作用是防止waitpid把调用者的执行挂起。

- 返回值

  成功返回等待子进程的ID， 失败返回-1.

### waitpid函数说明

对于waitpid的pid参数的解释与其值有关：

- pid == -1 等待任一子进程。于是在这一功能方面waitpid与wait等效。
- pid > 0等待其进程ID与pid相等的子进程。
- pid == 0 等待其组ID等于调用进程的组ID的任一子进程。换句话说是与调用者进程同在一个组的进程。
- pid < -1 等待其组ID等于pid的绝对值的任一子进程。

### wait和waitpid区别 

- 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选择项，可以使调用者不阻塞。
- waitpid并不等待第一个终止的子进程---它有若干个选项，可以控制它所等待的特定进程。
- 实际上wait函数是waitpid函数的一个特例。

### 如何避免僵进程

调用wait和waitpid函数查询子进程退出状态，此方法父进程会被挂起。

如果不想让父进程挂起，可以在父进程中加入一个语句：`signal(SIGCHLD, SIG_IGN)`; 表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程 发送的。

### system函数

- 功能：system( ) 函数调用`/bin/sh -c command` 执行特定的命令，阻塞当前进程直到command命令执行完毕。

- 原型

  ```c
  int system(const char *command);
  ```

- 返回值

  如果无法启动`shell`运行命令，system将返回127； 出现不能执行system调用的其他错误时返回-1。如果system能够顺利执行，返回那个命令的退出码。

- system函数执行时，会调用fork，execve，waitpid等函数。

### 什么是守护进程

- 守护进程是在==后台运行不受终端控制的进程==， 通常情况下守护进程在==系统启动时自动运行==。
- 守护进程的名称通常以`d`结尾，比如`sshd, xinetd, crond`等。

### 创建守护进程步骤

- 调用fork( ), 创建新进程，它会是将来的守护进程。
- 在父进程中调用`exit`, 保证子进程不是进程组组长。
- 调用`setsid`==创建新的会话期==。
- 将当前目录改为根目录
- 将标准输入， 标准输出， 标准错误重定向到`/dev/null`.

### daemon函数

- 功能：创建一个守护进程

- 原型：

  ```c
  int daemon(int nochdir, int noclose);
  ```

- 参数：

  nochdir: 当等于0时 将当前目录更改至`/`;

  noclose: 当等于0时 将标准输入， 标准输出，标准错误重定向至 `/dev/null`.

   
  
  

## 信号

### 中断

- 中断是系统对异步事件的响应。

  异步事件：没有时序关系，随机发生的事件

- 中断信号

- 中断源

- 现场信息

- 中断处理程序

- 中断向量表

### 中断分类

- 硬件中断（外部中断）：外部设备通过硬件请求的方式产生的中断。

  如：键盘中断，鼠标中断

- 软件中断（内部中断）：CPU运行程序错误或执行内部程序调用引起的中断

  如： cpu执行除0，INT指令，

### 信号

- 信号是UNIX系统响应某些状况而产生的事件，进程在接收到信号时会采取相应的行动。
- 信号是因为某些错误条件产生的，比如内存段冲突，浮点处理器错误或者非法指令。
- 信号是在软件层次上对中断一种模拟，所以他是一种软中断。

### 信号与中断

信号与中断相同点：

1. 采用相同的异步通信方式
2. 当检测出有信号或中断请求时，都暂停正在执行的程序而转去执行相应的处理程序。
3. 都在处理完毕后返回到原来的断点
4. 对信号或中断都可以进行屏蔽

信号与中断不同点：

1. 中断有优先级，而信号没有优先级，所有信号都是平等的。
2. 信号处理程序是在用户态下运行的，而中断处理程序是在核心态下运行的
3. 中断响应是及时的，而信号响应通常都有较大的事件延迟。

### 信号名称

信号的名称在头文件`<signal.h>`里定义

| 信号名称 |                描述                |
| :------: | :--------------------------------: |
| SIGABRT  |            进程停止运行            |
| SIGALRM  |               警告钟               |
|  SIGFPE  |            算术运算例外            |
|  SIGHUP  |              系统挂断              |
|  SIGILL  |              非法指令              |
|  SIGINT  |              终端中断              |
| SIGKILL  | 停止进程（此信号不能被忽略或捕获） |
| SIGPIPE  |      向没有读者的管道写入数据      |
| SIGSEGV  |            无效内存访问            |

### 进程对信号的三种响应

- 忽略信号

  SIGKILL（9号信号）, SIGSTOP（19号信号）除外

- 捕获并处理信号

  内核中断正在执行的代码，转去执行先前注册过的中断处理程序。

- 执行默认操作

  默认操作通常是终止进程， 这取决于被发送的信号。

### signal

```c
typedef void(*_sighandler_t)(int);
#define SIG_ERR((_sighandler_t)-1);
#define SIG_DFL((_sighandler_t)0);
#define SIG_IGN((_sighandler_t)1);
```

- 函数原型

```c
_sighandler_t signal(int signum, __sighandler_t handler);
```

- 参数

  signal是一个带signum和handler两个参数的函数，准备捕捉或屏蔽的信号由参数signum给出，接收到指定信号时将要调用的函数由handler给出。

  handler这个函数必须有一个int类型的参数（即接收到的信号代码），它本身的类型是void。

  handler也可以是下面两个特殊值：

  ```c
  SIG_IGN 	  屏蔽该信号
  SIG_DFL       恢复默认行为
  ```

### 信号分类

- 可靠信号

  支持排队，信号不会丢失

- 不可靠信号

  不支持排队，信号会丢失

- 实时信号

- 非实时信号

### 信号发送

```c
$ kill -9 pid        //向pid进程发送9号信号 将信号终止掉
```

- kill

  kill(pid, sig) 

  pid > 0, 信号sig发送给进程号==pid的进程

  pid = 0，信号sig将发送给调用者所在组的每一个进程

  pid = -1, 信号sig将被发送给调用者进程有权限发送的每一个进程，除了1号进程和自身之外。

  pid < -1, 信号sig将发送给进程组= -pid中的每一个进程。

- raise

  给自己发送信号。raise(sig)等价于kill(getpid(), sig);

- killpg

  给进程组发送信号。killpg(pgrp, sig)等价于kill(-pgrp,  sig);

- sigqueue

  给进程发送信号，支持排队，可以附带信息。

### pause函数

- 将进程置为可中断睡眠状态。然后它调用`schedule()`,使linux进程调度器找到另一个进程来运行。
- pause使调用者进程挂起，直到一个信号被捕获。

### 更k多信号发送函数

**alarm** 发送SIGALRM信号

**setitimer** 发送SIGALRM	SIGVTALRM	SIGPROF信号

**abort** 发送SIGABRT信号

### 可重入函数

为了增强程序的稳定性，在信号处理函数中应使用可重入函数

下列这些函数多数是不可重入的：

1. 使用静态的数据结构，如getlogin( ), gmtime( ), getgrgid()等等。
2. 函数实现时，调用malloc(), free()函数等；
3. 实现时使用标准I/O函数。

### 信号在内核的表示

执行信号的处理动作称为信号递达（Delivery），信号从产生到递达之间的状态，称为信号未决（Pending）。进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作。==Ps：== 阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。

![](/home/zhang/Pictures/Screenshot from 2021-04-15 10-02-07.png)

task_struct: 进程的结构体。

block：信号屏蔽字，信号掩码 （进行信号的阻塞）

pending：未决状态字

### 信号集操作函数

```c
#include <signal.h>

int sigemptyset(sigset_t *set);    //将信号位置0
int sigfillset(sigset_t *set);	   //将信号位置1
int sigaddset(sigset_t *set, int signo);    //将信号位置1
int sigdelset(sigset_t *set, int signo);    //将信号位置0
int sigismember(cosnt sigset_t *set, int signo);   //检查信号位的状态是0或1
```

上面函数并不会改变信号屏蔽字。

### sigprocmask函数

- 头文件`<signal.h>`

- 原型

  ```c
  int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
  ```

- 功能: 读取或更改进程的信号屏蔽字。

- 返回值：若成功返回0， 出错返回-1

- 如果oset是非空指针，则读取进程的当前信号屏蔽字通过oset参数传出。如果set是非空指针，则更改进程的信号屏蔽字，参数how指示如何更改。如果oset和set都是非空指针，则先将原来的信号屏蔽字备份到oset里，然后根据set和how参数更改信号屏蔽字。假设当前的信号屏蔽字为mask，下面解释了how参数使用方式。

**how参数的含义**

| SIG_BLOCK   | set包含了我们希望添加到当前信号屏蔽字的信号，相当于mask=mask\|set |
| ----------- | ------------------------------------------------------------ |
| SIG_UNBLOCK | set包含了我们希望添加到当前信号屏蔽字中解除阻塞的信号，相当于mask=mask&~set |
| SIG_SETMASK | 设置当前信号屏蔽字为set所指向的值，相当于mask=set            |

### sigaction函数

- 包含头文件`signal.h`

- 功能：sigaction函数用于改进进程接收到特定信号后的行为。

- 原型

  ```c
  int sigaction(int signum, const struct sigaction *act, const struct sigaction *old);
  ```

- 参数

  第一个参数为信号的值，可以为除SIGKILL和SIGSTOP外的任何一个特定有效信号。

  第二个参数是指向结构sigaction的一个实例指针，在结构sigaction的实例中，指定了特定信号的处理，可以为空，进程会以缺省方式对信号处理。

  第三个参数old指向的对象用来保存原来对相应信号的处理，可以指定old为NULL。

- 返回值：成功返回0，失败返回-1.

### sigaction结构体

第二个参数最为重要，其中包含了对指定信号的处理，信号所传递的信息，信号处理函数执行过程中应屏蔽掉哪些函数等。

```c
struct sigaction {
    void (*sa_handler) (int);
    void (*sa_sigaction) (int, siginfo_t *, void *);
    
    sigset_t sa_mask;
    int sa_flags;
    void （*sa_restorer）(void);   //不考虑该段
}
```

**sa_mask的阻塞与sigprocmask区别**

​	sa_mask短暂的阻塞，阻塞过了一段时间可以递达。

​	sigprocmask阻塞后就一直阻塞。

### sigqueue函数

- 功能: 新的发送信号系统调用，主要是针对实时信号提出的支持信号带有参数，与函数sigaction( ) 配合使用。

- 原型

  ```c
  int sigqueue(pid_t pid, int sig, const union sigval value);
  ```

- 参数

  第一个参数是指定接收信号的进程id

  第二个参数确定即将发送的信号

  第三个参数是一个联合数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。

- 返回值：成功返回0， 失败返回-1

### sigval联合体

sigqueue( ) 比 kill( ) 传递了更多的附加信息，但sigqueue( )只能向一个进程发送信号，而不能发送信号给一个进程组。

```c
typedef union sigval {
    int sival_int;
    void * sival_ptr;
}sigval_t;
```

### 三种不同精度的睡眠

```c
unsigned int sleep(unsigned int seconds);
int usleep(useconds_t usec);   //微秒为单位
int nanosleep(const struct timespec *req, struct timespec *rem); //纳秒级睡眠 参数一请求睡眠时间 参数二 剩余睡眠时间
```

### setitimer函数

alarm只产生一次SIGALARM信号， setitimer间歇性的产生SIGALARM信号。

`ITIMER_REAL: 经过指定的时间后，内核将发送SIGALRM信号给本进程`

`ITIMER_VIRTUAL:程序在用户空间执行指定的时间后，内核将发送SIGVTALRM信号给本进程`

`ITIMER_PROF:进程在内核空间执行时， 时间计数器会减少，通常与ITIMER_VIRTUAL共用，代表进程在用户空间与内核空间中运行指定时间后，内核将发送SIGPROF信号给本进程。`

## 线程



## 管道

### 管道定义

- 管道是Unix中最古老的进程间的通信方式。
- 我们把从一个进程连接到另一个进程的数据流称为管道。

**管道本质**有固定大小的内核缓冲区。

### 管道限制

- 管道是半双工的，数据只能向一个方向流动；需要双向通信时，需要建立两个管道。
- 只能用于具有公共祖先的进程（具有亲缘关系的进程）之间进行通信；通常一个管道由一个进程创建，然后该进程调用fork函数，此后父，子进程之间就可以应用管道。

### 匿名管道pipe

- 头文件`<unistd.h>`

- 功能：创建一个无名管道

- 原型

  ```c
  int pipe(int fd[2])
  ```

- 参数

  fd: 文件描述符数组，其中fd[0]表示读端，fd[1]表示写端。

- 返回值 成功返回0， 失败返回错误代码errorn。

### 管道读写规则

- 当没有数据可以读时

  O_NONBLOCK disable：read调用被阻塞，即进程暂停执行，一直等到所有数据到来为止。

  O_NONBLOCK enble：read调用返回-1，errno值为EAGAIN。

  非阻塞通过如下设置

  ```c
  int flags = fcntl(pipefd[0], F_GETFL);
  fcntl(pipefd[0], F_SETFL, flags|O_NONBLOCK);
  ```

- 当管道满的时候

  O_NONBLOCK disable：write调用被阻塞。

  O_NONBLOCK enble：write调用返回-1，errno值为EAGAIN。

- 如果所用管道写端对应的文件描述符被关闭，则read返回0

- 如果所有管道的读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE.

- 当要写入的数据量不大于PIPE_BUF时， linux将保证写入的原子性。

- 当要写入的数据量大于PIPE_BUF时， linux将不再保证写入的原子性。即不能保证一个进程写完再写另一个进程

  ==管道的容量不一定等于PIPE_BUF，Ubuntu的管道容量是64K，PIPE_BUF是4K。==



### 命名管道（FIFO）

- 管道应用的一个限制就是只能在具有共同祖先（具有血缘关系）的进程间通信
- 如果我们想在不相关的进程间交换数据，可以使用FIFO文件来做这项工作，他经常被称为命名管道。
- 命名管道是一种特殊类型的文件。

### 创建一个命名管道

- 命名管道可以从命令行上创建，命令行方法是使用此命令 `$ mkfifo filename`
- 命名管道也可以从程序中创建，相关函数如下：

```c
int mkfifo(const char *filename, mode_t mode);
```

### 匿名管道和命名管道区别

- 匿名管道由pipe函数创建并打开。
- 命名管道由mkfifo函数创建，打开使用open函数。
- FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在于它们创建与打开的方式不同，一旦这些工作完成，它们具有相同的语义。

### 命名管道的打开规则

- 如果当前打开操作是为读而打开FIFO时

  O_NONBLOCK disable：阻塞直到有相应进程为写而打开该FIFO

  O_NONBLOCK enable：立刻返回成功

- 如果当前打开操作是为写而打开FIFO时

  O_NONBLOCK disable：阻塞直到有相应进程为读而打开该FIFO

  O_NONBLOCK enable：立刻返回失败，错误码为ENXIO

  